
Win condition:
```
void win(unsigned int arg1, unsigned int arg2) {
  if (arg1 != 0xCAFEF00D)
    return;
  if (arg2 != 0xF00DF00D)
    return;
  printf(flag);
}
```

First, we check what kind of executable we're dealing with:
```
import pwn

elf = pwn.ELF('./vuln')   # This tels pwntools where our binary is, and that it's a local binary.
print(elf)
```
output:
```
┌─[root@edu-virtualbox]─[/home/edu/picoctf/buffer_overflow_2]
└──╼ #python3 exploit.py 
[*] '/home/edu/picoctf/buffer_overflow_2/vuln'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
ELF('/home/edu/picoctf/buffer_overflow_2/vuln')
```
So we're dealing with a 32-bit little endian binary, for i386 architecture.

To see if it's a stripped binary, we use  `file`.
```
┌─[root@edu-virtualbox]─[/home/edu/picoctf/buffer_overflow_2]
└──╼ #file vuln
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=a429aa852db1511dec3f0143d93e5b1e80e4d845, for GNU/Linux 3.2.0, not stripped
```
The binary is not stripped, so we can check the position of the `win` function using `readelf`:
```
┌─[root@edu-virtualbox]─[/home/edu/picoctf/buffer_overflow_2]
└──╼ #readelf -s vuln | grep win
    64: 08049296   162 FUNC    GLOBAL DEFAULT   15 win
```

Or using `pwntools:`
```
import pwn

elf = pwn.ELF('./vuln')   # This tels pwntools where our binary is, and that it's a local binary.
print(hex(elf.symbols["vuln"]))
```
output:
```
0x8049296
```

### Making the binary a process
The `pwntools` library has the `.process` function, making an executable a process.
This means it behaves as if it's a remote service (so you can use functions like `recv()` and `interactive()`), but locally.
To make the binary a process, use
```
p = elf.process()
```

To send data to the binary, use
```
p.sendline("data")
```
To recieve data (get output), use
```
print(p.recv())
```
For interactivity, use
```
p.interactive()
```


### Finding the offset of the return pointer
First, open `gef`
```

```